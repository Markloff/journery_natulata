---
title: Event Emitter
date: 2022/3/17
description: vscode/base/common/event 模块详解
tag: web development
author: marklov
---

# 实现自己的 Event Emitter

<blockquote>
	设想这样的场景，请提供一个通用的 Event Emitter 能力
</blockquote>

使用姿势:

```ts
class QQMusicPlayer {
    private readonly _onPlayStatusChange: Emitter<string> = new Emitter<string>();
    public readonly onPlayStatusChange = this._onPlayStatusChange.event;

    private readonly _audioEL: HTMLAudioElement;

	constructor() {
		this._audioEL = document.createElement('audio');
		this._audioEL.oncanplay = () => {
			this._onPlayStatusChange.fire('canPlay')
		}
	}

}

const player = new QQMusicPlayer();

player.onPlayStatusChange((status: string) => {
    console.log(status)
})
```

## 总体设计

- 使用数组或者链表保存传入的回调函数
- Emitter 内部的成员变量具有一定的懒加载能力，如果没有注册事件，则不会实例化
- 开放给外部的注册 register 能力，以及内部的 fire 能力需要区分开，以便实现上述能力

## 详细设计

### 链表还是数组

在存储回调函数的容器选择上，考虑到对后续 `dispose` 的支持 / 内存空间占用的优化，考虑使用链表实现

<blockquote>
	dispose 代表释放
</blockquote>


### 如何实现 Lazy Instantiation

访问 emitter.event 时，实例化未实例化的成员变量

### 如何实现 listener 的 unhook

对注册事件的行为，返回一个 实现了 IDisposable 能力的变量，当其执行了 dispose 的时候，执行对 listener 的 unhook，具体实现方式就是从链表上将这个 listener `node` 脱钩，那么 fire event 的时候，自然就跳过了这个 listener

## 实现

先实现一个 **链表** `linkedList.ts`

**Node**

```ts
class Node<E> {
	static readonly Undefined = new Node<any>(undefined);

	element: E;
	next: Node<E>;
	prev: Node<E>;
	constructor(element: E) {
		this.element = element;
		this.next = Node.Undefined;
		this.prev = Node.Undefined;
	}
}
```

<blockquote>
	这里有个小技巧
</blockquote>


`lifecycle.ts`

```ts
export interface IDisposable {
    dispose(): void;
}
```












